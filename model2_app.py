# -*- coding: utf-8 -*-
"""model2_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J2xtYk2VKOEYyE9TpST0rU-y_UujjBwc
"""

!pip install pathway bokeh

#model2_app.py (Model 2: Dynamic Pricing Model)
# This model implements a dynamic pricing model that adapts pricing based on occupancy, queue length, traffic conditions, whether it's a special day,
# and vehicle type. It visualizes the evolving prices using Bokeh
import pathway as pw
import pandas as pd
from bokeh.models import ColumnDataSource, HoverTool
from bokeh.plotting import figure, curdoc
from bokeh.layouts import column
from bokeh.transform import factor_cmap
from bokeh.palettes import Category20_20
import threading

#Pathway Schema
class ParkingData(pw.Schema):
    SystemCodeNumber: str
    Capacity: int
    Latitude: float
    Longitude: float
    Occupancy: int
    VehicleType: str
    TrafficConditionNearby: str
    QueueLength: int
    IsSpecialDay: int
    LastUpdatedDate: str
    LastUpdatedTime: str

#Reading dataset in streaming mode
input_table = pw.io.csv.read("dataset.csv", schema=ParkingData, mode="streaming", autocommit_duration_ms=1000)

#Combining date and time fields
@pw.udf
def combine_timestamp(date: str, time: str) -> str:
    return f"{date} {time}"

#Mapping helper UDFs for traffic and vehicle weight
@pw.udf
def map_traffic(val: str) -> int:
    return {"low": 0, "medium": 1, "high": 2}.get(val, 1)

@pw.udf
def map_vehicle(val: str) -> float:
    return {"car": 1.0, "bike": 0.6, "truck": 1.5}.get(val, 1.0)

#Dynamic pricing logic
@pw.udf
def model2_price(occupancy, capacity, queue, traffic, special, weight):
    base = 10.0
    lambda_ = 1.0
    a, b, c, d, e = 2.0, 0.5, 0.8, 2.0, 1.5
    try:
        ratio = occupancy / capacity if capacity > 0 else 0
        demand = a * ratio + b * queue - c * traffic + d * special + e * weight
        norm_demand = max(0, min(demand / 10, 1))
        price = base * (1 + lambda_ * norm_demand)
        return round(max(min(price, 20), 5), 2)
    except:
        return base

#Create pathway output table with calculated price
table = input_table.select(
    **input_table,
    Timestamp=combine_timestamp(input_table.LastUpdatedDate, input_table.LastUpdatedTime)
)

output_table = table.select(
    Timestamp=table.Timestamp,
    SystemCodeNumber=table.SystemCodeNumber,
    Occupancy=table.Occupancy,
    Capacity=table.Capacity,
    QueueLength=table.QueueLength,
    Traffic=map_traffic(table.TrafficConditionNearby),
    Price_Model2=model2_price(
        table.Occupancy,
        table.Capacity,
        table.QueueLength,
        map_traffic(table.TrafficConditionNearby),
        table.IsSpecialDay,
        map_vehicle(table.VehicleType)
    )
)

#our Output file
pw.io.csv.write(output_table, filename="stream_output_model2.csv")

#Start Pathway runtime
threading.Thread(target=pw.run, daemon=True).start()

#Bokeh
source = ColumnDataSource(data=dict(x=[], price=[], occ_ratio=[], queue=[], traffic=[]))
source_avg = ColumnDataSource(data=dict(x=[], y=[], lot=[]))

# Hover tooltips shared across all figures
hover_price = HoverTool(tooltips=[("Time", "@x{%F %T}"), ("Price", "@price")], formatters={"@x": "datetime"})
hover_occ = HoverTool(tooltips=[("Time", "@x{%F %T}"), ("Occ/Cap", "@occ_ratio")], formatters={"@x": "datetime"})
hover_queue = HoverTool(tooltips=[("Time", "@x{%F %T}"), ("Queue", "@queue")], formatters={"@x": "datetime"})
hover_traffic = HoverTool(tooltips=[("Time", "@x{%F %T}"), ("Traffic", "@traffic")], formatters={"@x": "datetime"})

fig_price = figure(title="Model 2: Dynamic Price", x_axis_type='datetime', width=1000, height=300, tools=[hover_price, "pan", "wheel_zoom", "box_zoom", "reset"])
fig_price.line('x', 'price', source=source, line_width=2, color="green")
fig_price.circle('x', 'price', size=6, color="green", source=source)
fig_price.yaxis.axis_label = "Price"
fig_price.xaxis.axis_label = "Timestamp"

fig_occ = figure(title="Occupancy / Capacity Ratio", x_axis_type='datetime', width=1000, height=250, tools=[hover_occ, "pan", "wheel_zoom", "box_zoom", "reset"])
fig_occ.line('x', 'occ_ratio', source=source, line_width=2, color="gray")
fig_occ.circle('x', 'occ_ratio', source=source, size=5, color="gray")
fig_occ.yaxis.axis_label = "Occ/Cap Ratio"

fig_queue = figure(title="Queue Length", x_axis_type='datetime', width=1000, height=250, tools=[hover_queue, "pan", "wheel_zoom", "box_zoom", "reset"])
fig_queue.line('x', 'queue', source=source, line_width=2, color="blue")
fig_queue.circle('x', 'queue', source=source, size=5, color="blue")
fig_queue.yaxis.axis_label = "Queue"

fig_traffic = figure(title="Traffic Intensity (0=low, 2=high)", x_axis_type='datetime', width=1000, height=250, tools=[hover_traffic, "pan", "wheel_zoom", "box_zoom", "reset"])
fig_traffic.line('x', 'traffic', source=source, line_width=2, color="red")
fig_traffic.circle('x', 'traffic', source=source, size=5, color="red")
fig_traffic.yaxis.axis_label = "Traffic"

fig_avg = figure(title="Model 2: Daily Avg Price Across Lots", x_axis_type='datetime', width=1000, height=400)
fig_avg.scatter('x', 'y', source=source_avg, size=6, color=factor_cmap('lot', palette=Category20_20, factors=[]), legend_field='lot')
fig_avg.xaxis.axis_label = "Timestamp"
fig_avg.yaxis.axis_label = "Avg Price"
fig_avg.legend.label_text_font_size = '8pt'
fig_avg.legend.location = "top_left"
fig_avg.add_tools(HoverTool(tooltips=[("Time", "@x{%F}"), ("Price", "@y"), ("Lot", "@lot")], formatters={"@x": "datetime"}))

# Track last read row
last_row = 0

def update():
    global last_row
    try:
        df = pd.read_csv("stream_output_model2.csv")
        df['Timestamp'] = pd.to_datetime(df['Timestamp'], format="%d-%m-%Y %H:%M:%S")
        df = df.sort_values('Timestamp')

        df_main = df[df['SystemCodeNumber'] == 'BHMBCCMKT01']
        if len(df_main) > last_row:
            new_rows = df_main.iloc[last_row:]
            x = new_rows['Timestamp']
            y = new_rows['Price_Model2']
            occ = new_rows['Occupancy']
            cap = new_rows['Capacity'].replace(0, 1)
            ratio = occ / cap
            q = new_rows['QueueLength']
            t = new_rows['Traffic']
            source.stream(dict(x=x, price=y, occ_ratio=ratio, queue=q, traffic=t), rollover=500)
            last_row = len(df_main)

        df['Timestamp'] = pd.to_datetime(df['Timestamp'], format="%d-%m-%Y %H:%M:%S")
        df['day'] = df['Timestamp'].dt.floor('d')
        avg_prices = df.groupby(['day', 'SystemCodeNumber'])['Price_Model2'].mean().reset_index()
        avg_prices['x'] = avg_prices['day']
        avg_prices['y'] = avg_prices['Price_Model2']
        avg_prices['lot'] = avg_prices['SystemCodeNumber']
        lots = avg_prices['lot'].unique().tolist()
        fig_avg.renderers = []
        fig_avg.scatter('x', 'y', source=source_avg, size=6,
                        color=factor_cmap('lot', palette=Category20_20, factors=lots), legend_field='lot')
        source_avg.data = avg_prices[['x', 'y', 'lot']].to_dict(orient='list')

    except Exception as e:
        print("Model2 update error:", e)

#Register update callback
curdoc().add_periodic_callback(update, 1000)
curdoc().add_root(column(fig_price, fig_occ, fig_queue, fig_traffic, fig_avg))