# -*- coding: utf-8 -*-
"""model1_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F70jco7yx9m_wrC0ZW1ZKH0IyBZZ29b3
"""

!pip install pathway bokeh

#model1_app.py (Model 1: Baseline Linear Model)
#This model implements a baseline linear pricing model (Model 1) where the price evolves based on occupancy/capacity and resets each day.
#It visualizes the real-time prices using Bokeh with both line and scatter plot (for the main lot), and a separate scatter-only plot for competition (with colored lots).

import pathway as pw
import pandas as pd
from bokeh.models import ColumnDataSource, HoverTool
from bokeh.plotting import figure, curdoc
from bokeh.layouts import column
from bokeh.transform import factor_cmap
from bokeh.palettes import Category20_20
import threading

#Pathway Schema
class ParkingData(pw.Schema):
    SystemCodeNumber: str
    Capacity: int
    Latitude: float
    Longitude: float
    Occupancy: int
    VehicleType: str
    TrafficConditionNearby: str
    QueueLength: int
    IsSpecialDay: int
    LastUpdatedDate: str
    LastUpdatedTime: str

#Reading dataset in streaming mode
input_table = pw.io.csv.read(
    "dataset.csv",
    schema=ParkingData,
    mode="streaming",
    autocommit_duration_ms=1000
)

#Combining date and time fields
@pw.udf
def combine_timestamp(date: str, time: str) -> str:
    return f"{date} {time}"

#Adding timestamp field
table = input_table.select(
    **input_table,
    Timestamp=combine_timestamp(input_table.LastUpdatedDate, input_table.LastUpdatedTime)
)

output_table = table.select(
    Timestamp=table.Timestamp,
    SystemCodeNumber=table.SystemCodeNumber,
    Occupancy=table.Occupancy,
    Capacity=table.Capacity
)

#Our Output file
pw.io.csv.write(output_table, filename="stream_output_model1.csv")

#Start Pathway
threading.Thread(target=pw.run, daemon=True).start()

#Bokeh plots
source_model = ColumnDataSource(data=dict(x=[], y=[]))
source_competition = ColumnDataSource(data=dict(x=[], y=[], lot=[]))

#Main lot line + scatter plot
plot_main = figure(title="Model 1 Price Over Time", x_axis_type='datetime', width=800, height=400)
plot_main.line('x', 'y', source=source_model, line_width=2, color="blue", legend_label="Model 1 Price")
plot_main.circle('x', 'y', size=6, color="blue", source=source_model)
plot_main.xaxis.axis_label = "Timestamp"
plot_main.yaxis.axis_label = "Price"
plot_main.legend.location = "top_left"
plot_main.add_tools(HoverTool(tooltips=[("Time", "@x{%F %T}"), ("Price", "@y")], formatters={"@x": "datetime"}))

#Competition plot with different colors per lot
plot_comp = figure(title="Model 1: Competition Across Lots", x_axis_type='datetime', width=800, height=400)
plot_comp.scatter('x', 'y', source=source_competition, size=6,
                  color=factor_cmap('lot', palette=Category20_20, factors=[]),
                  legend_field='lot', alpha=0.7)
plot_comp.xaxis.axis_label = "Timestamp"
plot_comp.yaxis.axis_label = "Price"
plot_comp.legend.label_text_font_size = '8pt'
plot_comp.legend.location = "top_left"
plot_comp.add_tools(HoverTool(tooltips=[("Time", "@x{%F %T}"), ("Price", "@y"), ("Lot", "@lot")], formatters={"@x": "datetime"}))

#Track last read row for streaming
last_row = 0

#Update function to simulate pricing evolution and stream data to Bokeh
def update():
    global last_row
    try:
        df = pd.read_csv("stream_output_model1.csv")
        df['Timestamp'] = pd.to_datetime(df['Timestamp'])
        df = df.sort_values('Timestamp')

        # --- Main Lot: BHMBCCMKT01 ---
        df_main = df[df['SystemCodeNumber'] == 'BHMBCCMKT01']
        x_model, y_model = [], []
        if len(df_main) > last_row:
            new_rows = df_main.iloc[last_row:]
            new_rows['Date'] = new_rows['Timestamp'].dt.date
            alpha = 2.0
            for date, group in new_rows.groupby('Date'):
                price = 10.0
                for _, row in group.iterrows():
                    occ = row['Occupancy']
                    cap = row['Capacity'] if row['Capacity'] > 0 else 1
                    price = min(price + alpha * (occ / cap), 20)
                    x_model.append(row['Timestamp'])
                    y_model.append(round(price, 2))
            source_model.stream(dict(x=x_model, y=y_model), rollover=500)

                # --- Competition Lot Daily Averages ---
        alpha = 2.0
        df['day'] = df['Timestamp'].dt.date
        df = df.sort_values(['SystemCodeNumber', 'Timestamp'])

        results = []
        for (lot, day), group in df.groupby(['SystemCodeNumber', 'day']):
            price = 10.0
            prices = []
            for _, row in group.iterrows():
                occ = row['Occupancy']
                cap = row['Capacity'] if row['Capacity'] > 0 else 1
                price = min(price + alpha * (occ / cap), 20)
                prices.append(price)
            avg_price = round(sum(prices) / len(prices), 2)
            results.append((pd.to_datetime(str(day)), avg_price, lot))

        df_comp = pd.DataFrame(results, columns=['x', 'y', 'lot'])

        lot_list = df_comp['lot'].unique().tolist()
        plot_comp.renderers = []  # Clear old
        plot_comp.scatter('x', 'y', source=source_competition, size=6,
                          color=factor_cmap('lot', palette=Category20_20, factors=lot_list),
                          legend_field='lot', alpha=0.7)
        source_competition.data = df_comp.to_dict(orient='list')
    except Exception as e:
        print("Model1 update error:", e)

#Register update callback
curdoc().add_periodic_callback(update, 1000)
curdoc().add_root(column(plot_main, plot_comp))